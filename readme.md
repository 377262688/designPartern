# 设计模式学习
极客时间-设计模式之美
## 软件设计原则 (SOLID)

- 开闭原则（Open Closed Principle，OCP）
- 单一职责原则（Single Responsibility Principle, SRP）
- 里氏代换原则（Liskov Substitution Principle，LSP）
- 依赖倒转原则（Dependency Inversion Principle，DIP）
- 接口隔离原则（Interface Segregation Principle，ISP）
- 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）
- 最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）
- DRY原则（dont do it repeat）
- KISS原则(Keep It Simple,Stupid)
- YAGNI原则
- LOD法则

## 设计模式
23种设计模式，分为创建型，结构型，行为型
### 1.创建型
- 常用的有：单例模式，工厂模式，建造者模式
- 不常用的有：原型模式
### 2.结构型
- 常用的有：代理模式，桥接模式，装饰者模式，适配器模式
- 不常用的有：门面模式，组合模式，享元模式
### 3.行为型
- 常用的有：观察者模式，模版模式，策略模式，职责链模式，迭代器模式，状态模式
- 不常用的有：访问者模式，备忘录模式，命令模式，解释器模式，中介模式

![avatar](https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png)

## 单例模式

实现关注点：

- 构造函数需要是 private，这样才能避免外部通过 new 创建实例
- 考虑创建时的线程安全问题
- 考虑是否支持延迟加载
- 考虑该getInstance 性能是否高

实现方式：
- 饿汉式 ： 在类加载时，实例已经创建好了，所以是线程安全的，缺点是不支持延迟加载。
- 懒汉式 ：懒汉式相对于饿汉式的优势是支持延迟加载，缺点是在每次获取实例的时候都会获取锁，并法度很低
- 双重检测 ：此方式支持延迟加载，只要instance被创建之后都会不再进入加锁逻辑。并法度很高。
- 内部类 ：这种方式是在调用时才会加载 SingletonHolder 类，实例的唯一性，创建安全性都有JVM来保证。
- 枚举 : 最简单的实现

如何破坏单例模式：

- 通过反射破坏单例，获取构造方法，设置权限，再实例化一个实例。防止被破坏的话就是在构造方法中加一个判断。
- 通过序列化反序列化来破坏单例，因为反序列化过程中，在反序列化执行过程中会执行到ObjectInputStream#readOrdinaryObject方法，
这个方法会判断对象是否包含readResolve方法，如果包含的话会直接调用这个方法获得对象实例。
反序列化也是调用构造函数来创建对象，但是反序列化和序列化调用的不是同一个，防止被破坏的方法就是重写readResolve方法

## 工厂模式

- 简单工厂

简单工厂就是给一个创建对象的工厂，简单，好用，

- 工厂方法

在简单工厂的基础上再创建一个工厂的工厂，这样会造成太多的类存在，除非是创造特别复杂的对象，一半简单工厂够用。

- 抽象工厂

用来创建多个工厂，不常用

使用例子有 Java 中的 Calendar , DateFormat , LocalDate 等

## 建造者模式

- 构造单个对象，如果必填属性很多，构造函数会很长，容易出错
- 校验逻辑放在build方法中，高内聚

与工厂模式的区别：
工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定参数来决定创建哪种对象。
建造者模式是用来创建一种类型复杂的对象，通过设置不同的可选参数，"定制化"的创建对象

## 原型模式

原型模式就是由于一个对象的创建成本比较大，比如需要经过比较复杂的计算，或者需要从RPC，网络，数据库，文件系统等慢速IO中读取，
这种情况下我们可以从一个已有的对象（原型）进行拷贝（复制）的方式来得到，达到节省时间的目的。

在Java中有clone方法，这里会涉及到 深拷贝（Deep Copy） 和 浅拷贝（Shallow Copy）

浅拷贝就是只会复制内存地址指针，而不会复制数据本身，深拷贝会复制数据。
浅拷贝和原始对象共享数据，而深拷贝得到的是一份独立的对象

深拷贝的两种实现方法：比浅拷贝要耗时，耗内存空间

- 1 递归的拷贝对象，直到要拷贝的对象只包含基本数据类型的数据。
- 2 先将对象序列化，然后再反序列化成新的对象。

## 代理模式

在不改变原始类（被代理类）代码的情况下，引入代理类来给原始类实现附加功能。

让原始类和代理类都实现相同的接口，在代理类中调用原始类的方法。

如果原始类没有定义接口，没法修改原始类的情况下，一半都使用继承方式实现.

以上的实现方式都有一个共同的问题，有多少类需要被代理，就需要创建多少代理类。会产生很多的类出来。

解决方式就是动态代理：

动态代理底层依赖的就是java 反射。Spring AOP 就是动态代理.

代理模式的应用场景：
- 业务系统的非功能性需求开发，如 监控，统计，鉴权，限流，事物，幂等，日志等，让代理类统一处理。

- 代理模式在RPC，缓存中使用，通过远程代理，将RPC的细节隐藏起来

## 桥接模式

将抽象和实现解耦，让它可以独立变化。
一个类存在两个或多个独立变化的唯独，我们通过组合的方式，让这两个或多个唯独可以进行独立扩展。

经典的桥接模式实现：JDBC等，是一种类之间的组合关系。

用组合模式来实现，在 com.mysql.jdbc.Driver 加载过程中，将它注册到 DriverManager 中，后续的获取链接，提交sql执行
等都委托给Driver 来实现。这些实现都是由 JDBC 抽象出来的。

## 装饰器模式

装饰器模式主要用来解决继承关系过于复杂的问题，典型的例子就是 Java io 包中 InputStream，OutputStream 的实现。
通过组合来替代继承，主要作用是给原始类添加增强功能，可以对原始类嵌套使用多个装饰器，设计时，装饰器类需要和原始类继承相同的抽象类或接口。

## 适配器模式
 适配器一般来说是一种时候补救的策略，将不兼容的接口转换为课兼容的接口，
 让原本不兼容的接口可以一起工作。两种实现方式，分别是类适配器和对象适配器

SLF4J 在LoggerFactory 类中的 bind() 方法中调用 findPossibleStaticLoggerBinderPathSet()中，会使用 ClassLoader
去查找 org/slf4j/impl/StaticLoggerBinder.class 资源。 
如果有多个 StaticLoggerBinder 存在，则会依次打印查找到的类。
然后调用 StaticLoggerBinder.getSingleton()，如果类路径下不存在 StaticLoggerBinder的话，
则会抛出 NoClassDefFoundError，进入异常处理流出

jvm 加载包名和类名相同的类的规则是，先加载 classpath 中 jar 路径放在前面的，只有第一个 jar 包会被引入，
第二个会在加载时判断已经被加载了而忽略。

StaticLoggerBinder 类就是典型的适配器实现。如果是log4j的话，在 StaticLoggerBinder 直接返回 Log4jLoggerFactory()

logback 则返回 LoggerContext, 后续返回的logger  都是实现了 log



