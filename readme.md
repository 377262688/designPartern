# 设计模式学习
极客时间-设计模式之美
## 软件设计原则 (SOLID)

- 开闭原则（Open Closed Principle，OCP）
- 单一职责原则（Single Responsibility Principle, SRP）
- 里氏代换原则（Liskov Substitution Principle，LSP）
- 依赖倒转原则（Dependency Inversion Principle，DIP）
- 接口隔离原则（Interface Segregation Principle，ISP）
- 合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）
- 最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）
- DRY原则（dont do it repeat）
- KISS原则(Keep It Simple,Stupid)
- YAGNI原则
- LOD法则

## 设计模式
23种设计模式，分为创建型，结构型，行为型
### 1.创建型
- 常用的有：单例模式，工厂模式，建造者模式
- 不常用的有：原型模式
### 2.结构型
- 常用的有：代理模式，桥接模式，装饰者模式，适配器模式
- 不常用的有：门面模式，组合模式，享元模式
### 3.行为型
- 常用的有：观察者模式，模版模式，策略模式，职责链模式，迭代器模式，状态模式
- 不常用的有：访问者模式，备忘录模式，命令模式，解释器模式，中介模式

![avatar](https://static001.geekbang.org/resource/image/f3/d3/f3262ef8152517d3b11bfc3f2d2b12d3.png)

## 单例模式

实现关注点：

- 构造函数需要是 private，这样才能避免外部通过 new 创建实例
- 考虑创建时的线程安全问题
- 考虑是否支持延迟加载
- 考虑该getInstance 性能是否高

实现方式：
- 饿汉式 ： 在类加载时，实例已经创建好了，所以是线程安全的，缺点是不支持延迟加载。
- 懒汉式 ：懒汉式相对于饿汉式的优势是支持延迟加载，缺点是在每次获取实例的时候都会获取锁，并法度很低
- 双重检测 ：此方式支持延迟加载，只要instance被创建之后都会不再进入加锁逻辑。并法度很高。
- 内部类 ：这种方式是在调用时才会加载 SingletonHolder 类，实例的唯一性，创建安全性都有JVM来保证。
- 枚举 : 最简单的实现

如何破坏单例模式：

- 通过反射破坏单例，获取构造方法，设置权限，再实例化一个实例。防止被破坏的话就是在构造方法中加一个判断。
- 通过序列化反序列化来破坏单例，因为反序列化过程中，在反序列化执行过程中会执行到ObjectInputStream#readOrdinaryObject方法，
这个方法会判断对象是否包含readResolve方法，如果包含的话会直接调用这个方法获得对象实例。
反序列化也是调用构造函数来创建对象，但是反序列化和序列化调用的不是同一个，防止被破坏的方法就是重写readResolve方法

## 工厂模式

- 简单工厂

简单工厂就是给一个创建对象的工厂，简单，好用，

- 工厂方法

在简单工厂的基础上再创建一个工厂的工厂，这样会造成太多的类存在，除非是创造特别复杂的对象，一半简单工厂够用。

- 抽象工厂

用来创建多个工厂，不常用

使用例子有 Java 中的 Calendar , DateFormat , LocalDate 等

## 建造者模式

- 构造单个对象，如果必填属性很多，构造函数会很长，容易出错
- 校验逻辑放在build方法中，高内聚

与工厂模式的区别：
工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定参数来决定创建哪种对象。
建造者模式是用来创建一种类型复杂的对象，通过设置不同的可选参数，"定制化"的创建对象

## 原型模式

原型模式就是由于一个对象的创建成本比较大，比如需要经过比较复杂的计算，或者需要从RPC，网络，数据库，文件系统等慢速IO中读取，
这种情况下我们可以从一个已有的对象（原型）进行拷贝（复制）的方式来得到，达到节省时间的目的。

在Java中有clone方法，这里会涉及到 深拷贝（Deep Copy） 和 浅拷贝（Shallow Copy）

浅拷贝就是只会复制内存地址指针，而不会复制数据本身，深拷贝会复制数据。
浅拷贝和原始对象共享数据，而深拷贝得到的是一份独立的对象

深拷贝的两种实现方法：比浅拷贝要耗时，耗内存空间

- 1 递归的拷贝对象，直到要拷贝的对象只包含基本数据类型的数据。
- 2 先将对象序列化，然后再反序列化成新的对象。

## 代理模式

在不改变原始类（被代理类）代码的情况下，引入代理类来给原始类实现附加功能。

让原始类和代理类都实现相同的接口，在代理类中调用原始类的方法。

如果原始类没有定义接口，没法修改原始类的情况下，一半都使用继承方式实现.

以上的实现方式都有一个共同的问题，有多少类需要被代理，就需要创建多少代理类。会产生很多的类出来。

解决方式就是动态代理：

动态代理底层依赖的就是java 反射。Spring AOP 就是动态代理.

代理模式的应用场景：
- 业务系统的非功能性需求开发，如 监控，统计，鉴权，限流，事物，幂等，日志等，让代理类统一处理。

- 代理模式在RPC，缓存中使用，通过远程代理，将RPC的细节隐藏起来

## 桥接模式

将抽象和实现解耦，让它可以独立变化。
一个类存在两个或多个独立变化的唯独，我们通过组合的方式，让这两个或多个唯独可以进行独立扩展。

经典的桥接模式实现：JDBC等，是一种类之间的组合关系。

用组合模式来实现，在 com.mysql.jdbc.Driver 加载过程中，将它注册到 DriverManager 中，后续的获取链接，提交sql执行
等都委托给Driver 来实现。这些实现都是由 JDBC 抽象出来的。

## 装饰器模式

装饰器模式主要用来解决继承关系过于复杂的问题，典型的例子就是 Java io 包中 InputStream，OutputStream 的实现。
通过组合来替代继承，主要作用是给原始类添加增强功能，可以对原始类嵌套使用多个装饰器，设计时，装饰器类需要和原始类继承相同的抽象类或接口。

## 适配器模式
 适配器一般来说是一种时候补救的策略，将不兼容的接口转换为课兼容的接口，
 让原本不兼容的接口可以一起工作。两种实现方式，分别是类适配器和对象适配器

SLF4J 在LoggerFactory 类中的 bind() 方法中调用 findPossibleStaticLoggerBinderPathSet()中，会使用 ClassLoader
去查找 org/slf4j/impl/StaticLoggerBinder.class 资源。 
如果有多个 StaticLoggerBinder 存在，则会依次打印查找到的类。
然后调用 StaticLoggerBinder.getSingleton()，如果类路径下不存在 StaticLoggerBinder的话，
则会抛出 NoClassDefFoundError，进入异常处理流出

jvm 加载包名和类名相同的类的规则是，先加载 classpath 中 jar 路径放在前面的，只有第一个 jar 包会被引入，
第二个会在加载时判断已经被加载了而忽略。

StaticLoggerBinder 类就是典型的适配器实现。如果是log4j的话，在 StaticLoggerBinder 直接返回 Log4jLoggerFactory()

logback 则返回 LoggerContext, 后续返回的logger  都是实现了 log

## 门面模式

门面模式为子系统提供一组统一的接口，定义一组接口让子系统更加易用。解决复用性和易用性之间的矛盾。

解决易用性问题：如Linux内核调用就是封装了多个接口
解决性能问题：App客户端需要调用 a，b，c三个接口，需要发起三次网络请求，可以再封装一个接口 x，来封装a，b，c三个请求
解决分布式事物问题：比如创建用户和创建钱包两个接口，需要两次调用，就需要分布式事物，可以引入分布式事物框架，或者事后补偿的方式来解决
这样复杂性很高，性能也比较底下。这样可以设计一个接口来完成这两个接口的调用，就可以一次解决事务问题。

尽量保持接口的复用性，针对特殊情况，于心提供门面接口，来提供更加易用的接口。

## 组合模式

组合模式提供一种树形的结构

## 享元模式

享元模式的目的是为了复用对象，节约内存，前提是享元对象是不可变对象。
如果一个对象在一个系统中大量复用，并且这些对象是不可变对象，就可以设计成享元。

享元模式在 Integer 中，String 中的应用

IntegerCache 中缓存了 -128 ～ 127 之间的Integer对象。当发生装箱或者调用valueOf 的时候，会先从 IntegerCache中获取。
Long，Short，Byte等也都缓存了这个段内的数据。
String 类的字符串常量池 也是享元模式的应用

## 观察者模式

在对象中定义一个一对多的依赖，当对象状态改变时，所有的依赖都会收到通知

被依赖的对象叫做被观察者（Observable），依赖的对象叫做观察者（Observer）

现实中称呼比较灵活。Subject-Observer，Publisher-Subscriber，Producer-Consumer，EventEmitter-EventListener，Dipatcher-Listener
只要应用场景符合定义，都可以叫做观察者模式。

## 模版方法模式

模版方法模式在一个方法中定义一个骨架，并将某些步骤推迟到子类中的实现。模版方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。

主要用抽象类实现，把一个算法中不变的流出抽象到父类的模版方法中，将可变的部分 method1，method2 留给子类实现，所有的子类都可以复用父类模版流程中的代码

### 复用
- JDK 中InputStream 中的 read() 方法就是一个模版方法。具体的实现由子类实现。
- java AbstractList中的 addAll(int index,Collection<? extends E> c) 就是一个模版方法，调用了add 方法，add由子类实现

### 扩展

- Java Servlet

只需要定义一个继承 HttpServlet 的类，重写其中的 doGet(),doPost()方法。其中 HttpServlet中的 service() 方法就是模版方法。

### 回调

回调 分为同步回调 和异步回调，同步回调更像是模版模式，异步回调更像是 观察者模式。

JdbcTemplate， RedisTemplate ,RestTemplate 都是基于回调来实现的。
还有addShutdownHook 

模版模式基于继承实现，回调基于组合实现

